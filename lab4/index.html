<!doctype html>
<html lang="en">

<head>
        <title>Lab 4 - Описание лабораторных работ</title>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">

        
        
        

        <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css">
            <link rel="stylesheet" href="../assets/css/darcula-highlight.min.css">

        <link rel="stylesheet" href="../assets/css/bootstrap.min.css">
        <link rel="stylesheet" href="../assets/css/dracula-ui.min.css">
        <link rel="stylesheet" href="../assets/css/mkdocs.min.css">

        
            <link  rel="icon" type="image/x-icon" href="../assets/img/favicon.ico">
        
            <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.5.0/highlight.min.js"></script>
                <script>hljs.initHighlightingOnLoad();</script>

</head>

<body class="drac-bg-black-secondary drac-text-grey-ternary drac-text drac-scrollbar-purple">

    <main class="d-flex">

        <!-- block sidebar -->
            <nav id="sidebar" class="sidebar drac-bg-black">
    <div class="custom-menu">
        <button type="button" id="sidebarCollapse" class="btn btn-primary">
            <i class="fa fa-bars"></i>
            <span class="sr-only">Menu</span>
        </button>
    </div>

    <div class="p-4">
        

        <div class="drac-text-center">
            
                <span class="drac-text drac-line-height drac-text-white">Описание лабораторных работ</span>
            
        </div>

        <div class="drac-box flex-column">
            <ul class="dot-ul">
                <li><div class="dot-li drac-bg-cyan"></div></li>
                <li><div class="dot-li drac-bg-green"></div></li>
                <li><div class="dot-li drac-bg-orange"></div></li>
                <li><div class="dot-li drac-bg-pink"></div></li>
                <li><div class="dot-li drac-bg-purple"></div></li>
                <li><div class="dot-li drac-bg-red"></div></li>
                <li><div class="dot-li drac-bg-yellow"></div></li>
            </ul>
        </div>

        <hr class="drac-divider" />

        <!-- block menu -->
        <ul class="mb-5 drac-list drac-list-none">
            
            <li class="drac-box">
                <a href=".."
                    class="
                    drac-anchor d-inline-flex align-items-center border-0 drac-text-purple--hover">
                    Home
                </a>
            </li>
            <li class="drac-box">
                <a href=".."
                    class="
                    drac-anchor btn-toggle d-inline-flex align-items-center border-0 drac-text-purple--hover collapsed"
                    data-bs-toggle="collapse" data-bs-target="#lab1-collapse" aria-expanded="false">
                    Lab1
                </a>
                <div class="collapse" id="lab1-collapse">
                    <ul class="mb-5 drac-list drac-list-none">
                            
    <li class="drac-box-ternary">
        <a href="../lab1/1/"
            class="
            drac-anchor d-inline-flex align-items-center border-0 drac-text-purple--hover">
            Task 1
        </a>
    </li>
                            
    <li class="drac-box-ternary">
        <a href="../lab1/2/"
            class="
            drac-anchor d-inline-flex align-items-center border-0 drac-text-purple--hover">
            Task 2
        </a>
    </li>
                            
    <li class="drac-box-ternary">
        <a href="../lab1/3/"
            class="
            drac-anchor d-inline-flex align-items-center border-0 drac-text-purple--hover">
            Task 3
        </a>
    </li>
                            
    <li class="drac-box-ternary">
        <a href="../lab1/4/"
            class="
            drac-anchor d-inline-flex align-items-center border-0 drac-text-purple--hover">
            Task 4
        </a>
    </li>
                            
    <li class="drac-box-ternary">
        <a href="../lab1/5/"
            class="
            drac-anchor d-inline-flex align-items-center border-0 drac-text-purple--hover">
            Task 5
        </a>
    </li>
                    </ul>
                </div>
            </li>
            <li class="drac-box">
                <a href="../lab2/"
                    class="
                    drac-anchor d-inline-flex align-items-center border-0 drac-text-purple--hover">
                    Lab 2
                </a>
            </li>
            <li class="drac-box">
                <a href="./"
                    class=" active 
                    drac-anchor d-inline-flex align-items-center border-0 drac-text-purple--hover">
                    Lab 4
                </a>
            </li>
        </ul>
        <!-- endblock -->
    </div>
</nav>
        <!-- endblock -->

        <nav class="divider drac-bg-purple-cyan"></nav>

        <div class="content">
            <!-- block header -->
                <header>
    <nav class="navbar navbar-expand-xl drac-bg-purple">
        <div class="container-fluid">
            
            <button class="navbar-toggler w-100 text-center" type="button" data-bs-toggle="collapse" data-bs-target="#navbarsMenu"
                aria-controls="navbarsMenu" aria-expanded="false" aria-label="Toggle navigation">
                <span class="navbar-toggler-icon"></span>
            </button>

            <div class="collapse navbar-collapse flex-column ml-auto" id="navbarsMenu">
                <ul class="navbar-nav text-md-center">

                    <!-- block preview -->
                    <li class="nav-item">
                            
        <div class="container">
            <div class="row row-preview">
                <div class="col">
                    <a href="../lab2/"
                        class="btn-preview drac-btn drac-btn-outline drac-text-white drac-text-cyan-green--hover">
                        <i class="fa fa-arrow-left"></i> Previous
                    </a>
                </div>
                <div class="col">
                    <a 
                        class="btn-preview drac-btn drac-text-white--hover disabled" style="padding-left: 3%;">
                        Next <i class="fa fa-arrow-right"></i>
                    </a>
                </div>
            </div>
        </div>
                    </li>
                    <!--  endblock -->

                    <!-- block search -->
                    <li class="nav-item"><div role="search" class="search-box">
	<form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
		<input type="text" name="q" class="drac-input drac-input-search drac-input-white drac-text-white drac-bg-black-secondary"
		placeholder="Search docs" title="Type search term here" />
	</form>
</div>
                    </li>
                    <!--  endblock -->

                    <!-- block source -->
                    <li class="nav-item">
                        
                    </li>
                    <!--  endblock -->

                </ul>
            </div>

        </div>
    </nav>
</header>
            <!-- endblock -->

            <!-- block content -->
                <section class="p-md-5 section-content">
    <article>
        <p><h1 id="no4">Лабораторная работа №4: Разработка интерфейсов и интеграция с серверной частью</h1>
<h2 id="_1">Задача проекта</h2>
<p>Разработать клиентские интерфейсы для работы с платформой предсказательного беттинга на базе блокчейна, настроить их взаимодействие с серверной частью.</p>
<h2 id="_2">Используемые библиотеки и их назначение</h2>
<h3 id="_3">Для бэкенда:</h3>
<ul>
<li><code>FastAPI</code>: Обработка серверной логики, включая аутентификацию пользователей и API.</li>
<li><code>SQLAlchemy</code>: Работа с базой данных.</li>
<li><code>pytoniq</code>: Взаимодействие с блокчейном TON, включая вызовы смарт-контрактов.</li>
<li><code>Pydantic</code>: Определение и валидация входных данных.</li>
</ul>
<h2 id="_4">Описание страниц интерфейса</h2>
<h3 id="_5">Главная страница</h3>
<ul>
<li><strong>Описание</strong>: Начальная страница, приветствующая пользователей и предоставляющая возможность подключения кошелька.</li>
<li><strong>Основные функции</strong>:</li>
<li>Приветственное сообщение и описание платформы.</li>
<li>Кнопка TonConnect для подключения кошелька.</li>
<li>Кнопки "Играть" и "Узнать больше" для навигации.
<img alt="img_1.png" src="img/img_1.png" />
<img alt="img_2.png" src="img/img_2.png" /></li>
</ul>
<h4 id="_6">Логика реализации:</h4>
<ul>
<li><strong>Подключение кошелька</strong>: Используется <code>TonConnectButton</code> для взаимодействия с TonConnect.</li>
<li><strong>Предзагрузка данных</strong>: При помощи функций <code>getPairs()</code> и <code>fetchTime()</code> данные о парах и текущем времени блока загружаются и сохраняются в контексте через <code>setData</code>.</li>
<li><strong>Обработка ошибок</strong>: Ошибки подключения и загрузки данных отображаются в пользовательском интерфейсе.</li>
<li><strong>Переходы</strong>: Кнопки навигации управляют переходом на другие страницы с использованием <code>useNavigate</code>.</li>
</ul>
<h3 id="_7">Страница ставок</h3>
<ul>
<li><strong>Описание</strong>: Предоставляет интерфейс для выбора торговых пар и размещения ставок. При первом открытии пользователю показываются инструкции.</li>
<li><strong>Основные функции</strong>:</li>
<li>Выбор торговой пары.</li>
<li>Ввод предсказания (вектор цены/направления движения).</li>
<li>Подтверждение и отправка ставки.
<img alt="img_3.png" src="img/img_3.png" /></li>
<li>на изображении: желтая стрелка - агрегированная ставка всех пользователей за прошлый блок, белая стрелка - ставка юзера за прошлый блок, ее же можно двигать, переключая моды осей, чтобы пояставить новую ставку.</li>
</ul>
<h4 id="_8">Логика реализации:</h4>
<ul>
<li><strong>Трёхмерный интерфейс ставок</strong>: Пользователи видят трехмерный график, на котором агрегированные ставки всех участников за прошлый блок и своя ставка в виде стрелок на графике.</li>
<li><strong>Обратная связь</strong>: После отправки пользователь получает уведомление о статусе ставки.</li>
</ul>
<h3 id="_9">Страница управления кошельком</h3>
<ul>
<li><strong>Описание</strong>: Позволяет пользователю управлять балансом кошелька, включая пополнение и вывод средств.</li>
<li><strong>Основные функции</strong>:</li>
<li>Форма пополнения депозита через TON.</li>
<li>Форма вывода средств на кошелек юзера.</li>
<li>История транзакций с отображением их статуса.</li>
<li>История ставок с отображением их статуса.
<img alt="img_5.png" src="img/img_5.png" /></li>
</ul>
<h4 id="_10">Логика реализации:</h4>
<ul>
<li><strong>Обработка пополнения</strong>: Запросы на сервер для обработки депозитов и их конвертации в токены платформы.</li>
<li><strong>Вывод средств</strong>: Инициирование транзакции на указанный адрес (есть возможность сменить адрес).</li>
</ul>
<h3 id="_11">Страница балансов юзера</h3>
<ul>
<li><strong>Описание</strong>: Позволяет пользователю узнать его оставшийся депозит в игре, а также количество токенов находящихся 'at risk'. </li>
<li><strong>Основные функции</strong>:</li>
<li>Отображение балансов юзера.</li>
<li>Кнопка для отключения кошелька.
<img alt="img_4.png" src="img/img_4.png" /></li>
</ul>
<h4 id="_12">Логика реализации:</h4>
<ul>
<li><strong>Обработка пополнения</strong>: Запросы на сервер для плучения балансов.</li>
</ul>
<h2 id="_13">Реализация авторизации</h2>
<h4 id="_14">Диаграмма процесса авторизации</h4>
<p><img alt="img.png" src="img/img.png" /></p>
<h3 id="_15">Описание работы</h3>
<p>Авторизация на платформе организована через интеграцию с блокчейном Ton и использованием механизма <code>ton_proof</code>. Весь процесс проходит несколько ключевых этапов:</p>
<ol>
<li><strong>Подключение кошелька:</strong></li>
<li>Пользователь подключает кошелёк через интерфейс TonConnect на клиенте.</li>
<li>
<p>Клиент отправляет запрос на сервер для генерации <code>payload</code>.</p>
</li>
<li>
<p><strong>Подписание proof:</strong></p>
</li>
<li>Полученный <code>payload</code> подписывается приватным ключом кошелька пользователя.</li>
<li>
<p>Подписанный proof возвращается на фронтенд, а затем отправляется на сервер для проверки.</p>
</li>
<li>
<p><strong>Проверка proof:</strong></p>
</li>
<li>Сервер валидирует подпись, проверяя её с публичным ключом пользователя в блокчейне.</li>
<li>
<p>Если proof валиден, сервер генерирует пару токенов (access и refresh) и отправляет их клиенту.</p>
</li>
<li>
<p><strong>Хранение и использование токенов:</strong></p>
</li>
<li>Токены сохраняются в <code>localStorage</code> на клиенте и используются для авторизации запросов к API.</li>
<li>При истечении срока действия токенов клиент автоматически обновляет их через refresh-токен.</li>
</ol>
<h2 id="_16">Основные компоненты бэкенда</h2>
<h3 id="1-ton_proof">1. Аутентификация и работа с <code>ton_proof</code></h3>
<h4 id="payload"><strong>Генерация Payload</strong></h4>
<pre><code class="language-python">@router.get('/payload')
async def generate_payload():
    tonproof_service = get_tonproof_service()
    payload = await tonproof_service.generate_payload()
    return {&quot;payload&quot;: payload}
</code></pre>
<p><strong>Объяснение логики:</strong>
- Генерируется уникальный токен (<code>payload</code>) с ограниченным временем жизни (TTL), который используется для подписи клиентом.
- Взаимодействие осуществляется через сервис <code>TonProofService</code>.</p>
<h4 id="proof"><strong>Проверка подписанного Proof</strong></h4>
<pre><code class="language-python">@router.post('/verify_payload')
async def verify_payload(credentials: Credentials):
    auth_service = get_auth_service()
    tokens = await auth_service.create_token(credentials)
    return {
        &quot;accessToken&quot;: tokens.access_token,
        &quot;refreshToken&quot;: tokens.refresh_token
    }
</code></pre>
<p><strong>Логика:</strong>
- Принимается <code>ton_proof</code>, подписанный пользователем.
- Проверяется достоверность подписи и её соответствие публичному ключу кошелька.
- При успешной проверке генерируются <code>access</code> и <code>refresh</code> токены для последующей работы клиента.</p>
<hr />
<h3 id="2-middleware">2. Middleware для проверки авторизации</h3>
<pre><code class="language-python">async def check_for_auth(request: Request, call_next):
    if request.url.path.startswith(('/auth', '/docs', '/openapi')) or request.method == 'OPTIONS':
        return await call_next(request)

    if 'Authorization' not in request.headers:
        return JSONResponse(status_code=401, content={'detail': 'Token is empty'})

    access_token = request.headers['Authorization'].replace('Bearer ', '')
    auth_service = get_auth_service()

    try:
        user_id = await auth_service.get_user_id_from_jwt(access_token)
    except InvalidTokenException:
        return JSONResponse(status_code=401, content={'detail': 'Token is invalid'})
    except ExpiredTokenException:
        return JSONResponse(status_code=401, content={'detail': 'Token is expired'})

    request.scope['x_user_id'] = user_id
    return await call_next(request)
</code></pre>
<p><strong>Назначение:</strong>
- Проверяет наличие и валидность токена.
- Извлекает <code>user_id</code> из токена и добавляет его в <code>scope</code> запроса для использования в хендлерах.</p>
<hr />
<h3 id="3-tonproofservice">3. Реализация <code>TonProofService</code></h3>
<h4 id="_17">Основные методы:</h4>
<ol>
<li><strong><code>generate_payload</code></strong>: Создаёт временный токен для подписи.</li>
<li><strong><code>check_payload</code></strong>:</li>
<li>Проверяет соответствие домена (<code>allowed_domains</code>).</li>
<li>Удостоверяется, что срок действия токена не истёк.</li>
<li>Проверяет подпись через <code>PyNaCl</code>.</li>
</ol>
<h4 id="_18"><strong>Пример валидации подписи</strong></h4>
<pre><code class="language-python">signature = base64.b64decode(request_raw.proof.signature)
public_key_bytes = bytes.fromhex(request_raw.public_key)
verify_key = VerifyKey(public_key_bytes)

try:
    verify_key.verify(msg_hash, signature)
    return VerifyResult.VALID
except BadSignatureError:
    return VerifyResult.HASH_MISMATCH
</code></pre>
<p><strong>Объяснение:</strong>
- Подпись проверяется с использованием публичного ключа пользователя.
- Если подпись недействительна, возвращается ошибка <code>HASH_MISMATCH</code>.</p>
<hr />
<h3 id="4-tokenservice">4. Сервис работы с токенами (<code>TokenService</code>)</h3>
<h4 id="_19">Генерация токенов</h4>
<pre><code class="language-python">def create_auth_token(self, wallet_address: str, payload: str) -&gt; AuthTokens:
    access_claims = {&quot;sub&quot;: wallet_address, &quot;payload&quot;: payload, &quot;exp&quot;: datetime.now(tz=UTC) + timedelta(seconds=600)}
    refresh_claims = {&quot;sub&quot;: wallet_address, &quot;payload&quot;: payload, &quot;exp&quot;: datetime.now(tz=UTC) + timedelta(days=1)}
    return AuthTokens(access_token=self.create_token(**access_claims), refresh_token=self.create_token(**refresh_claims))
</code></pre>
<p><strong>Логика:</strong>
- Генерирует два токена:
  - <strong><code>access_token</code></strong>: Используется для авторизации пользователя.
  - <strong><code>refresh_token</code></strong>: Позволяет обновить <code>access_token</code>, если он истёк.</p>
<h4 id="_20">Проверка токена</h4>
<pre><code class="language-python">def get_token_payload(self, token: str) -&gt; dict:
    try:
        return decode(token, self.jwt_settings.secret_key, algorithms=[&quot;HS256&quot;], issuer=self.jwt_settings.issuer)
    except ExpiredSignatureJWTError:
        raise ExpiredTokenException
    except InvalidTokenJWTError:
        raise InvalidTokenException
</code></pre>
<p><strong>Объяснение:</strong>
- Расшифровывает токен и проверяет его действительность.
- Возвращает данные, если токен валиден, или выбрасывает исключение в случае истечения срока или недействительности.</p>
<hr />
<h3 id="5-sqlalchemy">5. Работа с базой данных через SQLAlchemy</h3>
<h4 id="_21">Пример модели пользователя</h4>
<pre><code class="language-python">class User(Base):
    __tablename__ = &quot;users&quot;

    id = Column(UUID(as_uuid=True), primary_key=True, default=uuid4)
    wallet_address = Column(String, unique=True, nullable=False)
    username = Column(String, nullable=True)
    balance = Column(Float, default=0.0)
</code></pre>
<p><strong>Логика:</strong>
- Таблица <code>users</code> хранит информацию о кошельке, имени пользователя и балансе.</p>
<h4 id="_22">Пример метода репозитория для запроса к базе</h4>
<pre><code class="language-python">async def get_user_by_wallet(self, wallet_address: str) -&gt; User:
    async with self.sessionmaker() as session:
        res = await session.execute(select(User).where(User.wallet_address == wallet_address))
        res = res.scalars().one()
    return self.entity_to_model(res)
</code></pre>
<p><strong>Объяснение:</strong>
- Получает пользователя по адресу кошелька, используя синтаксис SQLAlchemy.</p>
<hr />
<h2 id="_23">Интеграция с блокчейном</h2>
<h4 id="web3py">Взаимодействие с Web3.py</h4>
<ul>
<li><strong>Отправка транзакций:</strong> Используется для обработки операций депозита и вывода.</li>
<li><strong>Чтение данных:</strong> Получает информацию о статусе кошелька или блоке.</li>
</ul>
<h4 id="_24">Пример отправки транзакции</h4>
<pre><code class="language-python">    async def send_jettons(
            self,
            user_wallet_address: Address,
            amount: int,
            token_address: Address,
            app_wallet: AppWalletWithPrivateData,
    ) -&gt; None:
        await self.ton.start_up()

        logger.debug('Preparing sending jettons')

        match app_wallet.wallet_version:
            case AppWalletVersion.V4R2:
                wallet_cls = WalletV4R2
            case AppWalletVersion.V5R1:
                raise UnsupportedWalletVersionException(
                    f&quot;Wallet version {app_wallet.wallet_version.value} is not supported&quot;
                )
            case _:
                raise UnsupportedWalletVersionException(
                    f&quot;Wallet version {app_wallet.wallet_version.value} is not supported&quot;
                )

        # Инициализируем кошелек администратора
        wallet = await wallet_cls.from_private_key(
            provider=self.ton,
            private_key=app_wallet.private_key.get_secret_value().encode(),
        )

        source_address = await self.get_wallet_address(
            contract_address=token_address,
            target_address=wallet.address,
        )

        payload = (
            begin_cell()
            .store_uint(0xf8a7ea5, 32)  # op::transfer
            .store_uint(0, 64)  # query_id
            .store_coins(amount)  # jettons to send
            .store_address(user_wallet_address)  # destination jetton wallet owner address
            .store_address()  # response address
            .store_dict()  # custom payload
            .store_coins(0)  # forward ton amount
            .store_maybe_ref()  # forward payload
            .end_cell()
        )

        logger.debug('Wallet initialized for sending tokens')

        # Выполняем вызов контракта с передачей подготовленного payload
        result = await wallet.transfer(
            destination=source_address,
            amount=int(0.01 * 1e9),  # Гарантируем оплату газа
            payload=payload,
        )

        if result &gt; 1:
            raise Exception(&quot;Sending jettons failed&quot;)

        logger.info(
            f&quot;Sent {amount} tokens &quot;
            f&quot;from {wallet.address.to_str(is_user_friendly=False)} &quot;
            f&quot;to {user_wallet_address.to_str(is_user_friendly=False)}&quot;
        )

        await self.ton.close_all()
</code></pre>
<h2 id="chainservice">Основные компоненты ChainService</h2>
<h3 id="chainservice_1"><strong>Сервис ChainService</strong></h3>
<p>ChainService отвечает за управление цепочками блоков, их статусами и процессами, включая генерацию новых блоков, обработку завершённых блоков и контроль транзакций.</p>
<hr />
<h3 id="1-apscheduler">1. <strong>APScheduler и его задачи</strong></h3>
<h4 id="_25"><strong>Основные задачи</strong></h4>
<ul>
<li><strong>Генерация новых блоков</strong> (<code>block_generation</code>):
  Периодически создаёт новые блоки для активных цепочек.</li>
<li><strong>Проверка транзакций пользователей</strong> (<code>transaction_check</code>):
  Проверяет статусы транзакций и обновляет данные пользователя.</li>
</ul>
<h4 id="_26"><strong>Настройка планировщика</strong></h4>
<pre><code class="language-python">def _add_generation_job(self):
    self.scheduler.add_job(
        self._generate_new_blocks,
        trigger=DateTrigger(run_date=datetime.now() + timedelta(seconds=self.block_generation_interval.seconds)),
        id=&quot;block_generation&quot;,
        replace_existing=True,
        misfire_grace_time=None,
    )
</code></pre>
<p><strong>Объяснение:</strong>
- Используется <code>DateTrigger</code> для запуска задачи через определённый интервал времени.
- Если задача уже существует, её поведение обновляется (<code>replace_existing=True</code>).</p>
<pre><code class="language-python">def _add_transaction_check_job(self):
    self.scheduler.add_job(
        self.deposit_service.check_users_transactions,
        trigger=IntervalTrigger(seconds=self.transaction_check_interval.seconds),
        id=&quot;transaction_check&quot;,
        replace_existing=True,
    )
</code></pre>
<p><strong>Объяснение:</strong>
- Используется <code>IntervalTrigger</code> для периодической проверки транзакций с фиксированным интервалом.</p>
<h4 id="_27"><strong>Инициализация планировщика</strong></h4>
<pre><code class="language-python">async def start_block_generation(self):
    await self._start_chains()
    self.scheduler.start()
    self._add_generation_job()
    self._add_transaction_check_job()
    self.logger.info(&quot;Сервис генерации блоков запущен.&quot;)
</code></pre>
<p><strong>Объяснение:</strong>
- Планировщик задач запускается с добавлением двух основных задач:
  - Генерация блоков.
  - Проверка транзакций.</p>
<hr />
<h3 id="2">2. <strong>Генерация и обработка блоков</strong></h3>
<h4 id="_28"><strong>Генерация новых блоков</strong></h4>
<pre><code class="language-python">async def _generate_new_blocks(self):
    try:
        chains = await self.chain_repository.get_all()
        for chain in chains:
            if chain.status == ChainStatus.PAUSED:
                continue

            last_block = await self.block_service.get_last_block(chain.id)

            if last_block:
                elapsed_time = (datetime.now() - last_block.created_at).seconds + 1
                if (elapsed_time &gt;= self.block_generation_interval.total_seconds()
                        and last_block.status == BlockStatus.IN_PROGRESS):
                    try:
                        rewards = await self._process_completed_block(last_block)
                    except StopPairProcessingException:
                        await self._pause_chain(chain)
                        continue

            new_block = await self.block_service.start_new_block(chain.id)
            if last_block:
                await self.block_service.process_completed_block(
                    block=last_block,
                    new_block_id=new_block.id,
                    rewards=rewards,
                )
            update_chain = UpdateChainDTO(
                current_block=new_block.block_number
            )
            await self.chain_repository.update(chain.id, update_chain)
    except Exception as e:
        self.logger.error(&quot;Ошибка генерации блоков&quot;, exc_info=True)
        raise e
</code></pre>
<p><strong>Объяснение:</strong>
- Для каждой активной цепочки проверяется статус последнего блока.
- Если блок завершён, обрабатывается с распределением наград.
- Создаётся новый блок, а данные цепочки обновляются в базе.</p>
<hr />
<h3 id="3">3. <strong>Проверка транзакций</strong></h3>
<pre><code class="language-python">def _add_transaction_check_job(self):
    self.scheduler.add_job(
        self.deposit_service.check_users_transactions,
        trigger=IntervalTrigger(seconds=self.transaction_check_interval.seconds),
        id=&quot;transaction_check&quot;,
        replace_existing=True,
    )
</code></pre>
<p><strong>Объяснение:</strong>
- Задача <code>check_users_transactions</code> проверяет статусы транзакций пользователей и обновляет их балансы.</p>
<hr />
<h3 id="4">4. <strong>Обработка завершённого блока</strong></h3>
<pre><code class="language-python">async def _process_completed_block(self, block: Block) -&gt; Rewards:
    await self.block_service.complete_block(block.id)
    try:
        result = await self.orchestrator_service.process_block(block_id=block.id)
        return result.rewards
    except StopPairProcessingException:
        self.logger.error(&quot;Обработка пары остановлена&quot;, exc_info=True)
        raise
</code></pre>
<p><strong>Объяснение:</strong>
- Завершённый блок обрабатывается, и на основе его данных рассчитываются награды.
- Если блок не может быть обработан (например, из-за ошибки пары), обработка цепочки приостанавливается.</p>
<hr />
<h3 id="5">5. <strong>Управление статусами цепочек</strong></h3>
<h4 id="_29"><strong>Пауза цепочки</strong></h4>
<pre><code class="language-python">async def _pause_chain(self, chain: Chain) -&gt; None:
    await self._stop_chain(chain)
    dto = UpdateChainDTO(status=ChainStatus.PAUSED)
    await self.chain_repository.update(chain.id, dto)
</code></pre>
<p><strong>Объяснение:</strong>
- Цепочка переводится в статус <code>PAUSED</code>, чтобы избежать создания новых блоков.</p>
<h4 id="_30"><strong>Остановка цепочки</strong></h4>
<pre><code class="language-python">async def _stop_chain(self, chain: Chain):
    current_block = await self.block_service.get_last_block(chain.id)
    await self.block_service.handle_interrupted_block(current_block.id)
</code></pre>
<p><strong>Объяснение:</strong>
- Если текущий блок в цепочке не завершён, он помечается как прерванный.</p>
<hr />
<h3 id="6">6. <strong>Получение текущего состояния блока</strong></h3>
<pre><code class="language-python">async def get_current_block_state(self, pair_id: UUID) -&gt; BlockStateResponse:
    try:
        last_block = await self.block_service.get_last_block_by_pair_id(pair_id)
        elapsed_time = (datetime.now() - last_block.created_at).total_seconds()
        remaining_time = max(0.0, self.block_generation_interval.total_seconds() - elapsed_time)

        return BlockStateResponse(
            block_id=last_block.id,
            server_time=str(datetime.now()),
            current_block=last_block.block_number,
            remaining_time_in_block=int(remaining_time),
        )
    except NotFoundException:
        raise
</code></pre>
<p><strong>Объяснение:</strong>
- Рассчитывает оставшееся время до завершения текущего блока.
- Возвращает данные для отображения на фронтенде.</p></p>
    </article>
</section>
            <!-- endblock -->

            <!-- block footer -->
                <footer>
    <div class="d-flex flex-sm-row justify-content-between py-2 border-top drac-text-black drac-bg-cyan-green">
        <a href="https://github.com/dracula/mkdocs" target="_blank" style="padding-left: 1%;"
            class="footer-text drac-anchor drac-text-black drac-text-purple--hover">
            Made with Dracula Theme for MkDocs
        </a>
    </div>
</footer>
            <!-- endblock -->
        </div>

    </main>

        <script>var base_url = '..';</script>
        <script src="../assets/js/jquery-3.3.1.slim.min.js"></script>
        <script src="../assets/js/bootstrap.bundle.min.js"></script>
        <script src="../assets/js/mkdocs.js"></script>
			<script src="../search/main.js" defer></script>

</body>

</html>